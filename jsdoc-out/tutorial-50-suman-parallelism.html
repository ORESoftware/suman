<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: 50-suman-parallelism</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: 50-suman-parallelism</h1>

    <section>

<header>
    

    <h2>50-suman-parallelism</h2>
</header>

<article>
    <p>This is an area where Suman really shines and has a lot of advantages over AVA etc.</p>
<p>I want to start with a super awesome example of how Suman rocks the party; personally I like to start with
a concrete example before speaking on generic terms, I learn better that way.</p>
<p>So here is the skeleton of our example test suite (copy it and run it).</p>
<pre class="prettyprint source lang-js"><code>const suman = require('suman');
const Test = suman.init(module, {});

//remember, we can use arrow functions everywhere except describes, since describes are responsible for
//creating a new context and binding it to the callback. 


Test.describe('Zulu', {parallel: false}, function () {  //root suite is *not* parallel (aka series)


    this.describe('A', {parallel: true}, function () { 

    });


    this.describe('B', {parallel: true}, function () {

    });


    this.describe('C', {parallel: true}, function () {

    });


    this.describe('D', {parallel: true}, function () {

    });


});</code></pre><p>You can see the pattern right? We have 4 child suites which are declared parallel and the 1 parent suite (the root suite)
 is declared  as being &quot;series&quot; because {parallel:false} for a parent will mean the child suites all run in series.</p>
<p>So now, let's flesh it out:</p>
<pre class="prettyprint source lang-js"><code>const suman = require('suman');
const Test = suman.init(module, {});

Test.describe('Zulu', {parallel: false}, function () {  //parent is series (parallel:false)


    this.describe('A', {parallel: true}, function () {

        this.it(this.desc + '1', function (t, done) {
            setTimeout(function () {
                done();
            }, 800);
        });

        this.it(this.desc + '2', function (t, done) {
            setTimeout(function () {
                done();
            }, 800);
        });

    });


    this.describe('B', {parallel: true}, function () {

        this.it(this.desc + '1', function (t, done) {
            setTimeout(function () {
                done();
            }, 500);
        });

        this.it(this.desc + '2', function (t, done) {
            setTimeout(function () {
                done();
            }, 500);
        });

    });


    this.describe('C', {parallel: true}, function () {


        this.it(this.desc + '1', function (t, done) {
            setTimeout(function () {
                done();
            }, 300);
        });

        this.it(this.desc + '2', function (t, done) {
            setTimeout(function () {
                done();
            }, 300);
        });

    });


    this.describe('D', {parallel: true}, function () {


        this.it(this.desc + '1', function (t, done) {
            setTimeout(function () {
                done();
            }, 100);
        });

        this.it(this.desc + '2', function (t, done) {
            setTimeout(function () {
                done();
            }, 100);
        });

    });

});</code></pre><p>As you can see above, each child suite's test cases ran in parallel, but the 4 child suites were actually run 
series. If they were run in parallel, then we would expect D's test cases to finish first. And now we flip the switch,
and we can see that D's test cases do in fact finish first, if we make the parent parallel:</p>
<pre class="prettyprint source lang-js"><code>const suman = require('suman');
const Test = suman.init(module, {});

Test.describe('Zulu', {parallel: true}, function () {   //now we make the parent parallel


    this.describe('A', {parallel: true}, function () {

        this.it(this.desc + '1', function (t, done) {
            setTimeout(function () {
                done();
            }, 800);
        });

        this.it(this.desc + '2', function (t, done) {
            setTimeout(function () {
                done();
            }, 800);
        });

    });


    this.describe('B', {parallel: true}, function () {

        this.it(this.desc + '1', function (t, done) {
            setTimeout(function () {
                done();
            }, 500);
        });

        this.it(this.desc + '2', function (t, done) {
            setTimeout(function () {
                done();
            }, 500);
        });

    });


    this.describe('C', {parallel: true}, function () {


        this.it(this.desc + '1', function (t, done) {
            setTimeout(function () {
                done();
            }, 300);
        });

        this.it(this.desc + '2', function (t, done) {
            setTimeout(function () {
                done();
            }, 300);
        });

    });


    this.describe('D', {parallel: true}, function () {


        this.it(this.desc + '1', function (t, done) {
            setTimeout(function () {
                done();
            }, 100);
        });

        this.it(this.desc + '2', function (t, done) {
            setTimeout(function () {
                done();
            }, 100);
        });

    });

});</code></pre><p>See the difference in the output? Play with this example and you will see the pattern.</p>
<p>The pattern is explained below.</p>
<p>So, what are the rules for how the parallel option works in Suman?
There are two places in Suman tests where we can choose something to run in parallel or in series.</p>
<p>Those two places are:</p>
<ol>
<li><p><code>Test.describe/this.describe('Foo', {parallel:false}, function(){});</code></p>
</li>
<li><p><code>this.it('foo', {parallel:true}, function(){});</code></p>
</li>
</ol>
<p>Here are the rules above how these operate. 
Let's start with case 2. For &quot;it&quot; test case functions, if &quot;it&quot; is declared as parallel, it will run in parallel with any other test case that is also declared parallel. 
It's that simple for it test cases</p>
<p>In the case of 1, for describes, declaring the describe block as parallel has two different effects.</p>
<ol>
<li>It switches the default for of any of the test cases that directly belong to that describe block.
Normally, to declare a test case as parallel we have to use {parallel:true}. However, if the containing describe suite
is declared parallel, then by default all the of the test cases will be run in parallel, unless they  explicitly use
parallel:false.</li>
</ol>
<p>Here is an example:</p>
<pre class="prettyprint source lang-js"><code>Test.describe('A', function(){

   this.describe('B', function(){

          //we stub the test cases out just for brevity's sake
          this.it('a');  //runs in series
          this.it('b');  //runs in series
          this.it('c');  //runs in series

   });

});

Test.describe('A', function(){

   this.describe('B', {parallel: true}, function(){

          //now, because the containing describe suite is declared parallel, all test cases default to parallel,
          //which can be convenient if you don't want to have to add {parallel: true} to each test case

          this.it('a');  //runs in parallel with other test cases
          this.it('b'); //runs in parallel with other test cases
          this.it('c'); //runs in parallel with other test cases

   });

});

and of course, to complete the picture, we can

Test.describe('A', function(){

   this.describe('B', {parallel: true}, function(){

          //now, because the containing describe suite is declared parallel, all test cases default to parallel,
          //which can be convenient if you don't want to have to add {parallel: true} to each test case

          this.it('a');  //runs in parallel with other test cases
          this.it('b', {parallel:false}); //runs first, then the other two tests run in parallel
          this.it('c'); //runs in parallel with other test cases

   });

});</code></pre><p>Now, let's get really nasty, let's do some more nesting to see what happens.</p>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Tutorials</h3><ul><li><a href="tutorial-01-getting-started.html">Getting Started with Suman</a></li><li><a href="tutorial-011-high-level-overview.html">Higher Level Overview</a></li><li><a href="tutorial-02-simple-examples.html">Simple Examples</a></li><li><a href="tutorial-05-advanced-use.html">Advanced Use</a></li><li><a href="tutorial-07-suman-patterns-and-recipes.html">Suman Patterns and Recipes</a></li><li><a href="tutorial-08-suman-anti-patterns.html">Suman Anti-Patterns</a></li><li><a href="tutorial-12-using-suman-with-babel.html">Using Suman with Babel</a></li><li><a href="tutorial-19-converting-from-mocha.html">Converting from Mocha to Suman</a></li><li><a href="tutorial-30-anatomy-of-suman-suite.html">Anatomy of Suman Test Suites</a></li><li><a href="tutorial-40-integrating-with-ci-cd.html">Integrating with CI/CD</a></li><li><a href="tutorial-50-suman-parallelism.html">50-suman-parallelism</a></li><li><a href="tutorial-90-roadmap.html">90-roadmap</a></li><li><a href="tutorial-99-faq.html">FAQ</a></li><li><a href="tutorial-bash.html">bash</a></li><li><a href="tutorial-suman-reporters.html">suman-reporters</a></li><li><a href="tutorial-suman-server-and-web-reporter.html">suman-server-and-web-reporter</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Apr 07 2016 15:29:52 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>